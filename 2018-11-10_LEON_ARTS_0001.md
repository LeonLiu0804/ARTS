
# 2018-11-10_ARTS_0001

## Algorithm

**Leetcode Algorithm: 204. Count Primes**  

**Description:  
Count the number of prime numbers less than a non-negative number, n.** 

*Example:
Input: 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.*



    //Source Code:  
    class Solution {
    public:
    int countPrimes(int n) {
        
        if (n < 3) return 0;
        vector<bool>bf(n, true); //Bool Flag
        bf[0] = bf[1] = false;
        for (int i = 2; i <= sqrt(n); ++i) 
        {
            if (!bf[i]) continue;
            for(int j = i*i; j <n; j+=i)
            {
                bf[j] = false;
            }
        }
        int res= 0;
        for (bool b: bf) 
        {
            res += (b) ? 1 : 0;
        }
        return res;

    }
    };
    
 求给定正整数列（1~n）中素数个数：  
 
 概念1 Prime Number 素数：又称质数，指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数。  
 
 概念2 和素数对应的是合数，如果一个数是合数，那么它的最小质因数肯定小于等于他的平方根。  
 
 算法核心：  
 
 1）0,1肯定是质数 ，遍历范围从2到n的平方根（用库函数“sqrt()” 求平方根 ）;因为sqrt（n）是n的最大因子，其后面的数对判断n是否为素数没有意义。  
 
 2）筛选法，建立bool型vector，初始值true；从2开始逐个遍历，每此遍历的对象i的倍数全部都不是素数，标记为false（例如 2,4,6,8...）；最后vector中为true的数字即全部为素数。  
 引申：如果不是求1~n，而是任意2个整数段，算法逻辑需要变化。  
 据说目前最大的素数是：277232917-1。它也是人类发现的第50个梅森素数，大素数是RSA等密码算法的基础。
 
 




## Review

## Tip

## Share
